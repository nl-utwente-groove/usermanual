Control is about scheduling rule executions. It provides a much stronger
mechanism than rule priorities (see \stref{rule-properties}).  Control is
specified in the form of a control program. The grammar of such programs is
given in Listing \ref{lst:control}.

\lstset{
	basicstyle=\ttfamily\scriptsize
}

\begin{figure}
\begin{lstlisting}[label=lst:control,caption={Grammar of Control Programs}]
program	: (function | stat)*
	;

function
	: 'function' ID '(' ')' block
	;

stat	: var_decl ';'
	| block
        | 'alap' stat
	| 'while' '(' cond ')' stat
	| 'until' '(' cond ')' stat
	| 'do' stat 'while' '(' cond ')'
	| 'do' stat 'until' '(' cond ')'
	| 'if' '(' cond ')' block ('else' block)?
	| 'try' block ('else' block)?
	| 'choice' block ('or' block)*
	| expression ';'
        ;

var_decl
	: var_type ID (',' ID)*
	;

var_type
	: 'node' | 'bool' | 'string' | 'int' | 'real'
	;

block	: '{' stat*  '}'
	;

cond	: cond_atom ('|' cond)?
	;

cond_atom
	: 'true' | rule ;

expr	: expr2 ('|' expr)*
	;

expr2	: expr_atom ('+' | '*')?
	| '#' expr_atom
	;

expr_atom
	: 'any'
	| 'other'
	| '(' expr ')'
	| call
	; 

call	: ID arg_list?
	;

arg_list
	: '(' (arg (',' arg)*)? ')'
	;

arg	: 'out'? ID
	| '_'
	| literal
	;

ID	: ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
	;
\end{lstlisting}
\end{figure}

A control program is interpreted during exploration of the grammer. In every
state, the control program decides which rules are scheduled (i.e. allowed to
be applied). A control program consists of a main control expressions, and
optionally a set of function definitions. We briefly list the main features of
the language.
%
\begin{itemize}
\item The smallest programming elements of a control program are the names of
  the rules in a grammar. Where such a name appear, only the named rule is scheduled.

\item Special cases are the keywords \anyK{} and \otherK. Both
  serve as a kind of wildcard over the available rules: \anyK{} executes
  any rule in the rule system, whereas \otherK{} executes any rule that
  does not explicitly appear in the control program. For instance, if the rule
  system has rules \textsf{a}, \textsf{b} and \textsf{c}, then the control
  program \textsf{a; \anyK; b; \otherK;} first only allows
  \textsf{a} to be applied, then one of \textsf{a}, \textsf{b} or \textsf{c},
  then \textsf{b}, and then \textsf{c}.

\item Control expressions can be built from rules and wildcards by 
\begin{itemize}\noitemsep
\item the infix operator ``\textsf{$|$}'', which specifies a choice among its
  operands;
\item the postfix operator ``\textsf{*}'', which specifies that its operand may
  be scheduled zero or more times;
\item the postfix operator ``\textsf{+}'', which specifies that its operand may
  be scheduled one or more times;
\item The prefix operator ``\textsf{\#}'', which specifies that its operand is
  scheduled as long as possible. 
\end{itemize}
The difference between ``\textsf{a*}'' and ``\textsf{\#a}'' is that the first
may optionally stop scheduling \textsf{a}, even if it is still applicable,
whereas the latter will continue trying \textsf{a} until it is no longer applicable.

\item Conditional statements allow the specification of an alternative in case
  certain rules do not have a matching. The conditions of \ifK,
  \whileK, \untilK{} and \doK-\whileK{} are restricted to a
  single rule name, \trueK, or a choice of rules. The condition holds
  when at least one of the options has a match.

\item The \tryK-\elseK{} statement allows more complex conditions, since the
  condition is incorporated in the body of the first block. In this case, the
  condition is true when any first possible rule (according to the block) has a
  match. The condition is false when the block does not lead to any rule
  application.  For instance, the program \textsf{\tryK{} \{a;b;\}
  \elseK{} \{c;d;\}} goes to the second block when rule \textsf{a}
  does not have a match.

\item The \alapK{} keyword stands for \emph{as long as possible}. In this case,
  the statement is exited when --- in a new iteration --- the block does not
  lead to any rule application. Thus, \alapK{} has the same effect as the
  prefix operator \textsf{\#}, except that it works on the level of statements
  rather than expresions.

\item The \choiceK-\doK{} statement has the same effect as the
  \textsf{$|$}-operator, except that it works on the level of statements rather
  than expressions.

\item Functions can be fedined by the keyword \functionK, followed by the
  function name, a pair of parentheses, and a function definition block. The
  parentheses are there for a possible future extension with
  parameters. Functions are called as expected; their semantics is defined by
  inlining. This means that recursive functions are not supported.
\end{itemize}
%
It is important to realise that control expressions are interpreted completely
\emph{deterministically}. This means that \textsf{\choiceK{} \{a;b;\} \orK{}
\{a;c;\}} has exactly the same meaning as \textsf{a; \choiceK{} \{b;\} \orK{}
\{c;\}}.

An example of a control program can be found in the \textsf{control.gps}
grammar in the \GROOVE samples.
