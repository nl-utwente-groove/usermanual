\section{Basic Concepts}
\stlabel{basic}

\Groove has two different modes for showing graphs and rules: the one you see
in the Editor when creating graphs and rules, and the one that you see in the
Simulator when applying rules. We call these the Edit and Display views,
respectively.  Historically, the Edit view only exists because we never took
the time to create a better graph editor; instead, we ripped off a prototype
editor provided for free with the \JGraph library.

\subsection{Graphs}
\stlabel{Graphs}

\Groove is based on directed node- and edge-labelled graphs. Graph nodes are
depicted as boxes, and edges as arrows between them; the node labels are
inscribed in the nodes, the edge labels along or on top of the arrows.

There are two kinds of node labels: types and flags. In the Edit view, these
are distinguished from one another and from edge labels by prefixing them with
``\typeP'' and ``\flagP'', respectively. If you omit the prefix, \Groove will
interpret the label as an edge label, and it will create a self-edge with that
label. (If you have no types or flags in your graph, self-edge labels remain
inscribed in the nodes in the Display view.) In the Display view, types are set
bold and flags are set italic. Here is an example:

\views{basic-graph}
%
% Self-edges (often also called loops), i.e., edges whose source and target nodes
% coincide, are sometimes not displayed as arrows; instead, their labels may be
% written on the node. For instance, the left and right hand side of
% \fref{self-edges} depict exactly the same graph. However, if node types or
% flags are used, loops are always properly displayed as edges.
%
% \begin{figure}[h]
% \begin{center}
% %\graphbox{self-edges-left}
% \tikzbox{self-edges-left}
% \qquad
% %\graphbox{self-edges-right}
% \tikzbox{self-edges-right}
% \end{center}
% \caption{Node labels represent self-edges, hence these two views depict the
% same graph.}
% \flabel{self-edges}
% \end{figure}
%
% In the \Groove{} views, multiple edges may be combined into a single edge with
% a comma-separated list of labels, or, in the case of self-edges, into a
% vertical list of node labels. In both cases, these lists actually represent
% multiple edges; for instance, the left and right hand sides of
% \fref{multiple-edges} depict the same graph.
%
% \begin{figure}[h]
% \begin{center}
% \graphbox{multiple-edges-left}
% \qquad
% \graphbox{multiple-edges-right}
% \end{center}
% \caption{Multiple labels represent multiple edges, hence these two views depict
% the same graph.}
% \flabel{multiple-edges}
% \end{figure}

\paragraph{Type and flag labels.}

As seen above, node labels can be either types or flags. There are two
important differences:
\begin{itemize}\noitemsep
\item Type labels are partially ordered. This affects rule matching: a type
  label in a rule matches all subtype labels (i.e., those that are smaller in
  the partial ordering) of the host graph.
\item If a type graph is used, type labels must be unique: every node must have
  exactly one type label.
\end{itemize}

\paragraph{Graph label syntax.}

Node labels are restricted to identifiers; i.e., strings of characters starting
with a letter or underscore, and containing only letters, digits, underscores
or dollar signs. It is also recommended, but not enforced, to use only
identifiers as edge labels. If you want to use other labels, start the label
(in the Edit view) with a colon (``\textsf{:}''). The colon will not be part of
the actual label: it is an escape character indicating that what follows should
be taken literally. (Thus, an initial colon serves as an ``escape'' character
precisely as an initial single quote serves as an escape in Excel.) Whitespace
other than simple spaces, such as tabs and newlines, cannot be included in
labels.

% \subsection{Node type labels}
% \stlabel{node types}
%
% Although, as stated above, node labels are actually self-edges, \Groove has a
% special convention to indicate that certain edge labels may \emph{only} be used
% for self-edges: namely, by preceding the label with the special prefix
% ``\textsf{type:}''. Such labels are intended to mimic node types, and in fact
% in almost all respects they do behave like node types. For instance, every node
% may have at most one ``\textsf{type:}''-prefixed self-edge; moreover, node type
% labels are always displayed as the topmost label in the node (in case there are
% more), and they are typeset in bold.
%
% \viewsfig[tikz]{node-types}{Edit and Display views of a graph with node types}
%
% For instance, \fref{node-types} shows two nodes with node type labels
% \textsf{Library} and \textsf{Book}, respectively. The \textsf{Book}-node has
% another self-edge \textsf{reserved}, also shown as a node label.

\subsection{Rules}
\stlabel{rules}

Formally, rules consist of left hand sides, right hand sides and negative
application conditions (NACs), all of which are different graphs, connected by
morphisms. In \Groove{} these graphs are combined into one single view, and
colour coding is used to distinguish the original components. As a consequence,
a \Groove{} view of a rule has the following kinds of elements:

\begin{description}
\item[Readers.] These are nodes and edges that are in both the LHS and the RHS.
  In both the editor and the display view, they are depicted just like ordinary
  graph elements; hence, the outlines are thin and black and the font colour is
  black. In the Edit view, the fact that an edge is a reader may be indicated
  explicitly by including an (optional) prefix ``\useP'' in front of the label.

\item[Erasers.] These are nodes and edges that occur in the LHS but not the
  RHS, meaning that they must be matched in order for the rule to apply, but by
  applying the rule they will be deleted. In the Display view, such elements
  are depicted by a thin, dashed blue outline and blue text; moreover, erased
  node labels (on non-erased nodes) are prefixed with ``textsf{--}''. In the
  Edit view, erasers are distinguished by a special prefix ``\delP''. For
  eraser nodes, this prefix should appear \emph{on its own} as a node label;
  for eraser edges, the prefix is followed by the edge label.

\item[Creators.] These are nodes and edges that occur in the RHS but not the
  LHS, meaning that they will be created when the rule is applied. In the
  Display view, such elements are depicted by a slightly wider, solid green
  outline (light grey in a black-and-white representation) and green text;
  moreover, created node labels (on non-created nodes) are prefixed with
  ``textsf{+}''. In the Edit view, creators are distinguished by a special
  prefix ``\newP''. For creator nodes, this prefix should appear \emph{on its
  own} as a node label; for creator edges, the prefix is followed by the edge
  label.

\item[Embargoes.] These are nodes and edges that are in a NAC, but not in the
  LHS. This means that they \emph{forbidden}: their presence in the host graph
  will prevent the rule from being applied. In the Display view, such elements
  are depicted by a wide, dashed red outline (darker grey in a black-and-white
  representation) and red text; moreover, forbidden node labels (on non-embargo
  nodes) are prefixed with ``\textsf{!}''. In the Edit view, creators are
  distinguished by a special prefix ``\notP''. For embargo nodes, this prefix
  should appear \emph{on its own} as a node label; for embargo edges, the
  prefix is followed by the edge label.
\end{description}
%
If a node plays any of the roles of eraser, creator or embargo, its incident
edges implicitly also have this role. Thus, in that case the corresponding
prefix can be omitted in the Edit view.

\medskip\noindent The following rule example contains all of the above types of elements:

\views{simple-rule}

Note that, among other things, this rule specifies the deletion and creation of
a type label; this is something that is forbidden in the presence of a type
graph.

\paragraph{Rule label syntax.}

Label parsing in rules is more complicated than in graphs, because there are
many more special labels (see below for a discussion). The following points
should be noted.
%
\begin{itemize}\noitemsep
\item The rule for the use of colons is the same as for graphs: when an
  (unquoted) colon is used as part of a label, there should be a single initial
  colon preceding the entire label; this initial colon is not considered to be
  part of the label itself.

\item In addition to the above, whenever the spacial characters \textsf{'}
  (single quote), \textsf{\textbackslash} (backslash), \textsf{?} (question
  mark), \textsf{!}  (exclamation mark), \textsf{=} (equality sign), or
  \textsf{\{} and \textsf{\}} (opening and closing curly braces) are used
  literally within labels, i.e., not in their role as special characters, the
  whole label must be single-quoted. The surrounding single quotes are
  themselves not considered to be part of the label.

\item The backslash (``\textsf{\textbackslash}'') serves as an escape character
  within a single-quoted label: any next character (including the backslash
  itself) is interpreted literally rather than as a special character. This is
  especially needed to use single quotes within single-quoted labels.
\end{itemize}
%
For instance, the label \textsf{'\textbackslash\textbackslash?\textbackslash''}
(ending on two single quotes) in a rule matches the label
\textsf{\textbackslash?'} in a graph.

\paragraph{Rule names.}

Rules have names. The names are essentially identifiers. The actual constraints
on rule names are quite flexible: any string that can be used as a file name
but does not contain spaces or periods is allowed as a rule name. However, it
is \emph{recommended} to stick to rule names that are valid identifiers:
%
\begin{itemize}\noitemsep
\item Start a rule name with a letter --- by convention a small letter;
\item Restrict the remaining characters to letters, digits, underscores or
  dollar characters.
\end{itemize}
%
Rule names can impose a hierarchical structure, similar to the package
structure of qualified Java class names. For instance, the name
``$\textsf{a.b}$'' stands for rule ``\textsf{b}'' in package
``\textsf{a}''. This mechanism is only there for the purpose of structuring
larger sets of rules; the structure does not change the meaning of the rule
system (see also \stref{grammars} below).

\paragraph{Example usage.}

The use of the above features is demonstrated by the following \Groove samples:
%
\begin{itemize}\noitemsep
\item \textsf{circular-buffer}, a simple data structure with two rules,
  containing creators, erasers and embargoes;
\item \textsf{loose-nodes}, showing that node labels are just self-edges which
  can be added to existing, non-labelled nodes.
\end{itemize}

\subsection{Negations}
\stlabel{negation}

Another way to forbid an edge is by inserting an exclamation mark in front of
its label. This therefore has the same effect as the ``\textsf{not:}'' prefix,
but it can only be used for edges. Moreover, negations can also be used
\emph{within} embargoes, achieving a double negation. For instance,
\fref{double-negation} expresses that the rule may only be applied if the
\textsf{Bus} has not already started (\textsf{!start}-self-edge), and there is
\emph{no} \textsf{Pupil} that is \emph{not} in the bus (\textsf{!in}-embargo
edge) --- in other words, if all the pupils are in the bus.

\viewsfig{double-negation}{
     Edit and Display views of a rule with double negation.
}

Negations may only be used on reader and embargo edges; in fact, they would be
meaningless when used on eraser or creator edges.

\subsection{Equalities, Mergers and Injectivities}
\stlabel{equality}

\Groove{} has a special label ``\textsf{=}'' (the equals sign). When used
between nodes in a rule, this expresses that the nodes are really the same,
despite being depicted as different. Such equality labels may also be used on
creator edges (which are then called \emph{mergers}) and embargo edges (which
are then called \emph{injectitivies}). Moreover, they may be combined with
negation.

\paragraph{Mergers.}

\Groove{} rules can \emph{merge} nodes. This is specified by a special edge
labelled ``\textsf{new:=}'' between the nodes that are to be merged. The
direction of the edge is irrelevant. When two nodes are merged, the resulting
node receives the incident edges of both original nodes (including the
self-edges). For instance, the rule in \fref{merger} specifies that the start
and final state of an automaton should be merged, while all incoming and
outgoing transitions are preserved.

\viewsfig{merger}{%
     Edit and Display views of a rule with a merger.
}

\paragraph{Injectivities.}

In general, rules are not matched injectively --- meaning that distinct LHS
nodes may be matche dby the same host graph node. (See, however,
\stref{system-properties} where we discuss how to set a global injectivity
constraint through the system properties.) Local injectivity can be enforced by
a special edge labelled ``\textsf{!=}'' or ``\textsf{not:=}:'' the end nodes of
such an edge will always have distinct images. Note that the direction of the
edge is irrelevant. For instance, the rule in \fref{injectivity} specifies that
a couple may only marry if they do not share parents.

\viewsfig{injectivity}{%
    Edit and Display views of a rule with two injectivity constraints.
}

\paragraph{Counting.}

As with ordinary labels, the effect of negation (an explamation mark) in front
of an equality is in principle the same as
that of the embargo prefix --- but again, negations can be used \emph{within}
embargoes. This has an important use in enabling \emph{counting} in rules. For
instance, \fref{counting} specifies that a \textsf{Plate} may only be put in
the \textsf{Oven} if it contains \emph{exactly} three \textsf{Roll}s --- no
more and no less. The injectivity between the reader \textsf{Roll}s ensures
that there are no less than two of them, whereas the embargo \textsf{Roll} with
its injectivities ensures that there are no more than two.

\viewsfig{counting}{Edit and Display views of a rule with a counting constraint}

\paragraph{Example usage.}

The use of the above features is demonstrated by the following \Groove samples:
%
\begin{itemize}\noitemsep
\item \textsf{mergers}, showing the use of mergers;
\item \textsf{counting}, demonstrating the principle of counting.
\end{itemize}

\subsection{Rule Comments}
\stlabel{remark}

To document rules, \Groove{} offers the possibility to add special nodes and
edges that do not make a difference to the transformation. This is done through
the prefix ``\textsf{rem:}'' (for ``remark''), either on a node (as a
stand-alone node label) or on an edge --- just as for the prefixes we have seen
so far. In the Display view, remark nodes and edges are orange, with a yellow
background. For instance, \fref{remark} is the same rule as \fref{counting},
augmented with remarks.

\viewsfig{remark}{Edit and Display views of a rule with remark elements}

\subsection{Rule properties}
\stlabel{rule-properties}

Apart from the LHS, RHS and NAC, which are depicted graphically, a rule also
has \emph{rule properties}. These can be accessed and modified either from the
Simulator or from the Editor. The most important of these properties is the
\emph{priority} of the rule. 

\paragraph{Priorities.}

Rule priorities provide a (primitive) way to
\emph{schedule} the application of rules: as long as a high-priority rule is
enabled, no lower-priority rules can be scheduled for application.

The default rule priority is 0. Creating rules with different priorities will
change the rules overview in the Simulator: another, top level is introduced in
this view, ordering groups of rules according to their priorities.

For instance, one can introduce a high-priority rule that just tests for the
presence of an ``\textsf{Error}''-labelled node, and does not modify the
graph. Such a rule would automatically halt the transformation of a graph if
some other rule introduces such an \textsf{Error}-node.

Rule system \textsf{priorities} in the \Groove{} samples shows an example use
of priorities.

\paragraph{Confluent.}

A rule may be marked as confluent if the user is certain that it does not
make a difference in which order matches of that rule are evaluated. The effect
is only visible in one particular exploration strategy (see \stref{exploration}),
the \emph{linear confluent} exploration. In this strategy, at every state only
the first match of a confluent rule is explored.

\paragraph{Enabledness.}

A rule can be \emph{disabled}, meaning that it is never scheduled for
application. This can be very useful when developing a graph grammar, since it
makes it easy to experiment with different versions of the same rule.

\paragraph{Comment.}

The rule comment provides another way to document a rule, in addition to the
remark nodes and edges already described in \stref{remark}.

\subsection{Transition systems}
\stlabel{trans}

During the evaluation of a set of rules, \Groove{} ``under water'' builds up a
so-called transition system, in which every graph plays the role of a state,
and every rule application is interpreted as a transition. The transitions bear
the names of the rules that have been applied as labels. The precise formatting
of the transition labels can be controlled by two system properties,
\textsf{transitionBrackets} and \textsf{transitionParameters}; see
\stref{system-properties}.

\paragraph{Rule systems and grammars}

A rule system is a set of rules, possibly with some addition information such
as a control specification (see \stref{control}) and system properties (see
\stref{system-properties}). A \emph{grammar} is a rule system together with a
start graph. The default start graph, called \textsf{start}, is assumed to be
available together with the rules; other start graphs can be specified or
loaded in, depending on the circumstances.

The structure of rule names (consisting of substrings separated by periods, see
\stref{rules}) in fact imposes a hierarchy of name spaces on the rule system,
but this hierarchy does not play a role in the evaluation of a graph grammar.
In other words, the meaning of a graph grammar does not change if all the rules
are arbitrarily renamed, including renamings that change the hierarchical
structure.
